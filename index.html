<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Awesome Browser Game</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      background: linear-gradient(to bottom, #87CEEB, #98FB98);
    }
  </style>
</head>
<body>
  <div id="game-container"></div>
  
  <script type="module">
    // Input System
    class Input {
      constructor(canvas) {
        this.left = false;
        this.right = false;
        this.jump = false;
        this.down = false; // Added for parachute

        // Keyboard
        window.addEventListener('keydown', e => {
          if (e.code === 'ArrowLeft' || e.code === 'KeyA') this.left = true;
          if (e.code === 'ArrowRight' || e.code === 'KeyD') this.right = true;
          if (e.code === 'Space' || e.code === 'ArrowUp') {
            this.jump = true;
            e.preventDefault();
          }
          if (e.code === 'ArrowDown' || e.code === 'KeyS') this.down = true; // Added for parachute
        });

        window.addEventListener('keyup', e => {
          if (e.code === 'ArrowLeft' || e.code === 'KeyA') this.left = false;
          if (e.code === 'ArrowRight' || e.code === 'KeyD') this.right = false;
          if (e.code === 'Space' || e.code === 'ArrowUp') this.jump = false;
          if (e.code === 'ArrowDown' || e.code === 'KeyS') this.down = false; // Added for parachute
        });

        // Touch
        canvas.addEventListener('touchstart', e => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = e.touches[0].clientX - rect.left;
          if (x < canvas.width / 2) this.left = true;
          else this.right = true;
          this.jump = true;
          this.down = true; // Added for parachute
        });

        canvas.addEventListener('touchend', e => {
          e.preventDefault();
          this.left = false;
          this.right = false;
          this.jump = false;
          this.down = false; // Added for parachute
        });
      }
    }

    // Audio System
    class AudioManager {
      constructor() {
        this.enabled = true;
        this.audioContext = null;
        this.initAudio();
      }

      initAudio() {
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.log('Audio not supported');
        }
      }

      play(name) {
        if (!this.enabled || !this.audioContext) return;
        
        // Simple beep sounds using Web Audio API
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        if (name === 'jump') {
          oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
        } else if (name === 'hit') {
          oscillator.frequency.setValueAtTime(220, this.audioContext.currentTime);
        }
        
        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
        
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + 0.1);
      }

      toggle() {
        this.enabled = !this.enabled;
      }
    }

    // Player Entity
    class Player {
      constructor(game, playerType = 0) {
        this.game = game;
        this.playerType = playerType;
        this.pos = { x: 100, y: 100 };
        this.vel = { x: 0, y: 0 };
        this.width = 40;
        this.height = 40;

        this.speed = 200;
        this.jumpForce = -400;
        this.gravity = 1000;
        this.isGrounded = false;

        this.color = '#00caff';
        // Super mode
        this.superCharge = 1; // 0 to 1
        this.superActive = false;
        this.superMax = 1; // max charge
        this.superDrainRate = 0.25; // per second
        this.superFillRate = 0.15; // per second
        this.superSpeed = 400;  
        this.superJump = -700;
        this.superKeyDown = false;
        // Powerup effects
        this.blasterPower = 1; // 1=norma, 2=strong
        this.blasterLevel = 1; // 1=normal, 2=double, 3=rapid, 4=grenade
        this.blasterTimer = 0;
        this.platformPower = 1; // 1=normal, 2=big
        this.platformTimer = 0;
        this.parachuteActive = false; // Added for parachute
        this.blasterPacks = [true, true, true, true]; // Added for blaster packs
        this.mineCount = 0;
        this.mines = [];
      }

      update(dt, input, platforms = []) {
        // Super mode charge
        if (!this.superActive && this.superCharge < this.superMax) {
          this.superCharge = Math.min(this.superMax, this.superCharge + this.superFillRate * dt);
        }
        // Super mode activation
        if (this.superKeyDown && this.superCharge > 0) {
          this.superActive = true;
          this.superCharge = Math.max(0, this.superCharge - this.superDrainRate * dt);
          if (this.superCharge === 0) this.superActive = false;
        } else {
          this.superActive = false;
        }
        // Powerup timers
        if (this.blasterLevel > 1) {
          this.blasterTimer -= dt;
          if (this.blasterTimer <= 0) {
            this.blasterLevel = 1;
          }
        }
        if (this.platformPower > 1) {
          this.platformTimer -= dt;
          if (this.platformTimer <= 0) this.platformPower = 1;
        }
        // Parachute activation: press down while airborne
        if (input.down && !this.isGrounded && !this.parachuteActive) {
          this.parachuteActive = true;
        }
        // Parachute deactivation: land on ground or platform
        if (this.isGrounded && this.parachuteActive) {
          this.parachuteActive = false;
        }
        // Horizontal Movement
        this.vel.x = 0;
        let moveSpeed = this.superActive ? this.superSpeed : this.speed;
        if (input.left) this.vel.x = -moveSpeed;
        if (input.right) this.vel.x = moveSpeed;
        // Jump
        let jumpForce = this.superActive ? this.superJump : this.jumpForce;
        if (input.jump && this.isGrounded) {
          this.vel.y = jumpForce;
          this.isGrounded = false;
          this.game.audio.play('jump');
          this.game.particles.emit(this.pos.x + this.width/2, this.pos.y + this.height, { count: 10, color: '#bada55', speed: 80, spread: Math.PI, size: 3, life: 0.3, angle: Math.PI/2 });
        }
        // Gravity or parachute fall
        if (this.parachuteActive) {
          // Slow fall
          if (this.vel.y > 100) this.vel.y = 100;
          else this.vel.y += this.gravity * dt * 0.2; // gentle gravity
        } else {
          this.vel.y += this.gravity * dt;
        }
        // Apply velocity
        this.pos.x += this.vel.x * dt;
        this.pos.y += this.vel.y * dt;
        // Keep player on screen horizontally
        if (this.pos.x < 0) this.pos.x = 0;
        if (this.pos.x + this.width > this.game.canvas.width) {
          this.pos.x = this.game.canvas.width - this.width;
        }
        // Platform collision
        this.isGrounded = false;
        for (const platform of platforms) {
          const p = platform.getBounds();
          if (
            this.vel.y >= 0 &&
            this.pos.y + this.height <= p.y + 8 &&
            this.pos.y + this.height + this.vel.y * dt >= p.y &&
            this.pos.x + this.width > p.x &&
            this.pos.x < p.x + p.width
          ) {
            this.pos.y = p.y - this.height;
            this.vel.y = 0;
            this.isGrounded = true;
          }
        }
        // Ground collision
        const groundY = this.game.canvas.height - this.height - 20;
        if (this.pos.y >= groundY) {
          this.pos.y = groundY;
          this.vel.y = 0;
          this.isGrounded = true;
        }
      }

      render(ctx) {
        if (this.playerType === 0) {
          // Original: blue square
          ctx.fillStyle = this.superActive ? '#ff0' : this.color;
          ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height);
          ctx.fillStyle = 'white';
          ctx.fillRect(this.pos.x + 8, this.pos.y + 8, 6, 6);
          ctx.fillRect(this.pos.x + 26, this.pos.y + 8, 6, 6);
          ctx.fillRect(this.pos.x + 12, this.pos.y + 24, 16, 4);
        } else if (this.playerType === 1) {
          // Red circle
          ctx.fillStyle = this.superActive ? '#ff0' : '#e74c3c';
          ctx.beginPath();
          ctx.arc(this.pos.x + this.width/2, this.pos.y + this.height/2, this.width/2, 0, Math.PI*2);
          ctx.fill();
          // Eyes
          ctx.fillStyle = 'white';
          ctx.beginPath(); ctx.arc(this.pos.x+14, this.pos.y+18, 4, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(this.pos.x+26, this.pos.y+18, 4, 0, Math.PI*2); ctx.fill();
          // Smile
          ctx.strokeStyle = 'white';
          ctx.beginPath(); ctx.arc(this.pos.x+20, this.pos.y+26, 6, 0, Math.PI); ctx.stroke();
        } else if (this.playerType === 2) {
          // Green triangle
          ctx.fillStyle = this.superActive ? '#ff0' : '#2ecc40';
          ctx.beginPath();
          ctx.moveTo(this.pos.x + this.width/2, this.pos.y);
          ctx.lineTo(this.pos.x + this.width, this.pos.y + this.height);
          ctx.lineTo(this.pos.x, this.pos.y + this.height);
          ctx.closePath();
          ctx.fill();
          // Eyes
          ctx.fillStyle = 'white';
          ctx.beginPath(); ctx.arc(this.pos.x+14, this.pos.y+28, 3, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(this.pos.x+26, this.pos.y+28, 3, 0, Math.PI*2); ctx.fill();
          // Smile
          ctx.strokeStyle = 'white';
          ctx.beginPath(); ctx.arc(this.pos.x+20, this.pos.y+34, 5, 0, Math.PI); ctx.stroke();
        }
        // Super charge bar
        ctx.save();
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = '#222';
        ctx.fillRect(this.pos.x, this.pos.y - 12, this.width, 6);
        ctx.fillStyle = '#ff0';
        ctx.fillRect(this.pos.x, this.pos.y - 12, this.width * (this.superCharge / this.superMax), 6);
        ctx.restore();
        // Draw parachute if active
        if (this.parachuteActive) {
          ctx.save();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(this.pos.x + this.width / 2, this.pos.y - 8, this.width / 2 + 4, Math.PI, 2 * Math.PI);
          ctx.stroke();
          ctx.restore();
        }
      }

      getBounds() {
        return {
          x: this.pos.x,
          y: this.pos.y,
          width: this.width,
          height: this.height,
        };
      }
    }

    // Collision Detection
    function checkCollision(a, b) {
      return (
        a.x < b.x + b.size &&
        a.x + a.width > b.x &&
        a.y < b.y + b.size &&
        a.y + a.height > b.y
      );
    }

    // Game States
    class Menu {
      constructor(game) {
        this.game = game;
        this.clickListener = null;
        this.selected = 0;
      }

      enter() {
        document.body.style.cursor = 'pointer';
        this.selected = this.game.selectedPlayerType;
        this.keyHandler = (e) => {
          if (e.code === 'ArrowLeft') this.selected = (this.selected + 2) % 3;
          if (e.code === 'ArrowRight') this.selected = (this.selected + 1) % 3;
          if (e.code === 'Enter' || e.code === 'Space') {
            this.game.selectedPlayerType = this.selected;
            this.game.stateManager.changeState('classic');
          }
        };
        window.addEventListener('keydown', this.keyHandler);
        this.clickListener = (e) => {
          // Click to select character
          const w = this.game.canvas.width;
          const h = this.game.canvas.height;
          for (let i = 0; i < 3; i++) {
            const cx = w/2 + (i-1)*120;
            const cy = h/2;
            if (Math.abs(e.clientX - cx) < 50 && Math.abs(e.clientY - cy) < 50) {
              this.selected = i;
              this.game.selectedPlayerType = i;
              this.game.stateManager.changeState('classic');
            }
          }
        };
        document.body.addEventListener('click', this.clickListener);
      }

      exit() {
        if (this.clickListener) {
          document.body.removeEventListener('click', this.clickListener);
          this.clickListener = null;
        }
        window.removeEventListener('keydown', this.keyHandler);
        document.body.style.cursor = 'default';
      }

      update() {}

      render(ctx) {
        ctx.clearRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        ctx.fillStyle = 'white';
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Awesome Game', this.game.canvas.width / 2, this.game.canvas.height / 2 - 120);
        ctx.font = '24px sans-serif';
        ctx.fillText('Select Your Character', this.game.canvas.width / 2, this.game.canvas.height / 2 - 60);
        // Draw character options
        for (let i = 0; i < 3; i++) {
          ctx.save();
          const cx = this.game.canvas.width/2 + (i-1)*120;
          const cy = this.game.canvas.height/2;
          ctx.translate(cx, cy);
          ctx.globalAlpha = (this.selected === i) ? 1 : 0.5;
          // Draw preview
          if (i === 0) {
            ctx.fillStyle = '#00caff';
            ctx.fillRect(-40/2, -40/2, 40, 40);
            ctx.fillStyle = 'white';
            ctx.fillRect(-40/2+8, -40/2+8, 6, 6);
            ctx.fillRect(-40/2+26, -40/2+8, 6, 6);
            ctx.fillRect(-40/2+12, -40/2+24, 16, 4);
          } else if (i === 1) {
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(-6, -2, 4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(6, -2, 4, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.beginPath(); ctx.arc(0, 8, 6, 0, Math.PI); ctx.stroke();
          } else if (i === 2) {
            ctx.fillStyle = '#2ecc40';
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(20, 20);
            ctx.lineTo(-20, 20);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(-6, 8, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(6, 8, 3, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.beginPath(); ctx.arc(0, 14, 5, 0, Math.PI); ctx.stroke();
          }
          if (this.selected === i) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.strokeRect(-28, -28, 56, 56);
          }
          ctx.restore();
        }
        ctx.font = '20px sans-serif';
        ctx.fillStyle = 'white';
        ctx.fillText('Use ← → or click to select, Enter/Space to start', this.game.canvas.width / 2, this.game.canvas.height / 2 + 80);
      }
    }

    // Bullet class
    class Bullet {
      constructor(x, y, speed = -500) {
        this.x = x;
        this.y = y;
        this.radius = 6;
        this.speed = speed;
        this.active = true;
      }

      update(dt) {
        this.y += this.speed * dt;
        if (this.y < -20) this.active = false;
      }

      render(ctx) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#ffff00';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.restore();
      }

      getBounds() {
        return {
          x: this.x - this.radius,
          y: this.y - this.radius,
          width: this.radius * 2,
          height: this.radius * 2,
          size: this.radius * 2
        };
      }
    }

    // Platform class
    class Platform {
      constructor(x, y, width = 40, height = 12) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }

      render(ctx) {
        ctx.save();
        ctx.fillStyle = '#bada55';
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.strokeStyle = '#333';
        ctx.strokeRect(this.x, this.y, this.width, this.height);
        ctx.restore();
      }

      getBounds() {
        return {
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height,
        };
      }
    }

    // Powerup class
    class Powerup {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.size = 28;
        this.type = type; // 'blaster' or 'platform'
        this.active = true;
        this.duration = 6; // seconds
      }

      render(ctx) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x + this.size/2, this.y + this.size/2, this.size/2, 0, Math.PI * 2);
        ctx.fillStyle = this.type === 'blaster' ? '#ff0' : '#0f0';
        ctx.globalAlpha = 0.85;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.font = '16px sans-serif';
        ctx.fillStyle = '#333';
        ctx.textAlign = 'center';
        ctx.fillText(this.type === 'blaster' ? 'B' : 'P', this.x + this.size/2, this.y + this.size/2 + 6);
        ctx.restore();
      }

      getBounds() {
        return {
          x: this.x,
          y: this.y,
          width: this.size,
          height: this.size,
          size: this.size
        };
      }
    }

    // Particle system
    class Particle {
      constructor(x, y, vx, vy, color, life, size) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.life = life;
        this.size = size;
        this.maxLife = life;
      }
      update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
        this.vy += 400 * dt; // gravity for some effects
      }
      render(ctx) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
    class ParticleSystem {
      constructor() {
        this.particles = [];
      }
      emit(x, y, options = {}) {
        const {
          count = 8,
          color = 'white',
          speed = 120,
          spread = Math.PI * 2,
          size = 3,
          life = 0.5,
          gravity = true
        } = options;
        for (let i = 0; i < count; i++) {
          const angle = (spread === 0 ? 0 : Math.random() * spread) + (options.angle || 0);
          const s = speed * (0.7 + Math.random() * 0.6);
          const vx = Math.cos(angle) * s;
          const vy = Math.sin(angle) * s;
          this.particles.push(new Particle(x, y, vx, vy, color, life * (0.7 + Math.random() * 0.6), size));
        }
      }
      update(dt) {
        this.particles.forEach(p => p.update(dt));
        this.particles = this.particles.filter(p => p.life > 0);
      }
      render(ctx) {
        this.particles.forEach(p => p.render(ctx));
      }
    }

    class ModeClassic {
      constructor(game) {
        this.game = game;
        this.enemies = [];
        this.bullets = [];
        this.platforms = [];
        this.powerups = [];
        this.spawnTimer = 0;
        this.spawnInterval = 2;
        this.score = 0;
        this.shootCooldown = 0;
        this.shootDelay = 0.25; // seconds
        this.shootKeyDown = false;
        this.cameraY = 0;
        this.maxHeight = 0;
        this.powerupTimer = 0;
        this.worldHeight = 4000; // Fixed world height in pixels
        this.finishFlag = null;
        this.win = false;
        this.mineKeyDown = false;
        this.mineKeyWasDown = false;
      }

      enter() {
        this.enemies = [];
        this.bullets = [];
        this.platforms = [];
        this.powerups = [];
        this.score = 0;
        this.spawnTimer = 0;
        this.spawnInterval = 2;
        this.shootCooldown = 0;
        this.shootKeyDown = false;
        this.cameraY = 0;
        this.maxHeight = 0;
        this.powerupTimer = 0;
        this.player = new Player(this.game, this.game.selectedPlayerType);
        // Start player higher
        this.player.pos.x = this.game.canvas.width / 2 - this.player.width / 2;
        this.player.pos.y = this.worldHeight - 120;
        // Add a starting platform above the ground
        const platWidth = 100;
        const platHeight = 16;
        const platX = this.game.canvas.width / 2 - platWidth / 2;
        const platY = this.worldHeight - 60;
        this.platforms.push(new Platform(platX, platY, platWidth, platHeight));
        // Add finish flag at the very top
        const flagWidth = 60;
        const flagHeight = 16;
        const flagX = this.game.canvas.width / 2 - flagWidth / 2;
        const flagY = 20;
        this.finishFlag = new Platform(flagX, flagY, flagWidth, flagHeight);
        // Keyboard shoot (Z key)
        this.keydownHandler = (e) => {
          if (e.code === 'KeyZ') this.shootKeyDown = true;
        };
        this.keyupHandler = (e) => {
          if (e.code === 'KeyZ') this.shootKeyDown = false;
        };
        window.addEventListener('keydown', this.keydownHandler);
        window.addEventListener('keyup', this.keyupHandler);
        // Mouse/touch shoot
        this.shootTouchHandler = (e) => {
          this.shootKeyDown = true;
        };
        this.shootTouchEndHandler = (e) => {
          this.shootKeyDown = false;
        };
        this.game.canvas.addEventListener('mousedown', this.shootTouchHandler);
        this.game.canvas.addEventListener('mouseup', this.shootTouchEndHandler);
        this.game.canvas.addEventListener('touchstart', this.shootTouchHandler);
        this.game.canvas.addEventListener('touchend', this.shootTouchEndHandler);
        // Super mode input
        this.superKeyDownHandler = (e) => {
          if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') this.player.superKeyDown = true;
        };
        this.superKeyUpHandler = (e) => {
          if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') this.player.superKeyDown = false;
        };
        window.addEventListener('keydown', this.superKeyDownHandler);
        window.addEventListener('keyup', this.superKeyUpHandler);
        // Blaster pack activation keys
        this.blasterKeyHandler = (e) => {
          if (e.code === 'Digit1' && this.player.blasterPacks[0]) this.activateBlasterPack(1);
          if (e.code === 'Digit2' && this.player.blasterPacks[1]) this.activateBlasterPack(2);
          if (e.code === 'Digit3' && this.player.blasterPacks[2]) this.activateBlasterPack(3);
          if (e.code === 'Digit4' && this.player.blasterPacks[3]) this.activateBlasterPack(4);
        };
        window.addEventListener('keydown', this.blasterKeyHandler);
        this.mineKeyHandler = (e) => {
          if (e.code === 'KeyX') this.mineKeyDown = true;
        };
        this.mineKeyUpHandler = (e) => {
          if (e.code === 'KeyX') {
            if (this.player.blasterLevel === 4 && this.player.mineCount > 0) {
              const px = this.player.pos.x + this.player.width / 2;
              const py = this.player.pos.y + this.player.height;
              this.player.mines.push({ x: px, y: py, radius: 18, active: true });
              this.player.mineCount--;
            }
            this.mineKeyDown = false;
          }
        };
        window.addEventListener('keydown', this.mineKeyHandler);
        window.addEventListener('keyup', this.mineKeyUpHandler);
      }

      exit() {
        window.removeEventListener('keydown', this.keydownHandler);
        window.removeEventListener('keyup', this.keyupHandler);
        this.game.canvas.removeEventListener('mousedown', this.shootTouchHandler);
        this.game.canvas.removeEventListener('mouseup', this.shootTouchEndHandler);
        this.game.canvas.removeEventListener('touchstart', this.shootTouchHandler);
        this.game.canvas.removeEventListener('touchend', this.shootTouchEndHandler);
        window.removeEventListener('keydown', this.superKeyDownHandler);
        window.removeEventListener('keyup', this.superKeyUpHandler);
        window.removeEventListener('keydown', this.blasterKeyHandler);
        window.removeEventListener('keydown', this.mineKeyHandler);
        window.removeEventListener('keyup', this.mineKeyUpHandler);
      }

      update(dt) {
        if (this.win) return; // Block movement if won
        this.player.update(dt, this.game.input, this.platforms.concat([this.finishFlag]));
        // Blaster powerup timer/level logic
        if (this.player.blasterLevel > 1 && this.player.blasterLevel !== 4) {
          this.player.blasterTimer -= dt;
          if (this.player.blasterTimer <= 0) {
            this.player.blasterLevel = 1;
          }
        }
        // For blasterLevel 4, only reset to 1 when all mines are used:
        if (this.player.blasterLevel === 4 && this.player.mineCount === 0 && this.player.mines.length === 0) {
          this.player.blasterLevel = 1;
        }
        // Shooting
        this.shootCooldown -= dt;
        if (this.shootKeyDown && this.shootCooldown <= 0) {
          const px = this.player.pos.x + this.player.width / 2;
          const py = this.player.pos.y;
          if (this.player.blasterLevel === 1) {
            this.bullets.push(new Bullet(px, py, -500));
            this.shootCooldown = this.shootDelay;
            this.game.particles.emit(px, py, { count: 8, color: '#ffff99', speed: 180, spread: Math.PI/2, size: 2, life: 0.25, angle: -Math.PI/2 });
          } else if (this.player.blasterLevel === 2) {
            this.bullets.push(new Bullet(px - 8, py, -800));
            this.bullets.push(new Bullet(px + 8, py, -800));
            this.shootCooldown = this.shootDelay;
          } else if (this.player.blasterLevel === 3) {
            this.bullets.push(new Bullet(px - 8, py, -900));
            this.bullets.push(new Bullet(px + 8, py, -900));
            this.shootCooldown = 0.08; // rapid fire
          }
          this.game.audio.play('jump');
        }
        // Update bullets
        this.bullets.forEach(bullet => bullet.update(dt));
        this.bullets = this.bullets.filter(b => b.active);

        this.player.mines = this.player.mines.filter(mine => mine.active);
        this.player.mines.forEach(mine => {
          this.enemies.forEach((enemy, eIdx) => {
            if (mine.active &&
              enemy.x < mine.x + mine.radius &&
              enemy.x + enemy.size > mine.x - mine.radius &&
              enemy.y < mine.y + mine.radius &&
              enemy.y + enemy.size > mine.y - mine.radius) {
              mine.active = false;
              // Turn enemy into platform
              const platSize = enemy.size * this.player.platformPower;
              this.platforms.push(new Platform(enemy.x, enemy.y + enemy.size - 8, platSize, 12 * this.player.platformPower));
              this.enemies.splice(eIdx, 1);
              this.game.audio.play('hit');
              this.game.particles.emit(mine.x, mine.y, { count: 24, color: '#ffb84d', speed: 200, spread: Math.PI*2, size: 4, life: 0.5 });
            }
          });
        });
        // Spawn enemies
        this.spawnTimer += dt;
        if (this.spawnTimer >= this.spawnInterval) {
          this.spawnEnemy();
          this.spawnTimer = 0;
          this.spawnInterval = Math.max(0.5, this.spawnInterval * 0.97);
        }
        // Update enemies
        this.enemies.forEach((enemy, index) => {
          enemy.y += enemy.speed * dt;
          // Remove enemies that are off screen
          if (enemy.y > this.game.canvas.height) {
            this.enemies.splice(index, 1);
          }
        });
        // Bullet-enemy collision
        this.bullets.forEach(bullet => {
          this.enemies.forEach((enemy, eIdx) => {
            if (checkCollision(bullet.getBounds(), enemy) && bullet.active) {
              bullet.active = false;
              // Turn enemy into platform
              const platSize = enemy.size * this.player.platformPower;
              this.platforms.push(new Platform(enemy.x, enemy.y + enemy.size - 8, platSize, 12 * this.player.platformPower));
              this.enemies.splice(eIdx, 1);
              this.game.audio.play('hit');
              this.game.particles.emit(enemy.x + enemy.size/2, enemy.y + enemy.size/2, { count: 16, color: '#ff4d4d', speed: 200, spread: Math.PI*2, size: 3, life: 0.4 });
            }
          });
        });
        // Powerup collision: each blaster powerup increases level (up to 4) and resets timer
        this.powerups.forEach((powerup, idx) => {
          if (checkCollision(this.player.getBounds(), powerup) && powerup.active) {
            if (powerup.type === 'blaster') {
              // Give next available pack (lowest not owned)
              for (let i = 0; i < 4; i++) {
                if (!this.player.blasterPacks[i]) {
                  this.player.blasterPacks[i] = true;
                  break;
                }
              }
            } else if (powerup.type === 'platform') {
              this.player.platformPower = 2;
              this.player.platformTimer = powerup.duration;
            }
            powerup.active = false;
          }
        });
        this.powerups = this.powerups.filter(p => p.active);
        // Check for collisions
        const playerBounds = this.player.getBounds();
        for (const enemy of this.enemies) {
          if (checkCollision(playerBounds, enemy)) {
            this.game.audio.play('hit');
            this.game.stateManager.changeState('menu');
            return;
          }
        }
        // Game over if player falls below screen
        if (this.player.pos.y - this.cameraY > this.game.canvas.height) {
          this.game.audio.play('hit');
          this.game.stateManager.changeState('menu');
          return;
        }
        // Win condition: player lands on finish flag
        const p = this.finishFlag.getBounds();
        const b = this.player.getBounds();
        if (
          b.y + b.height <= p.y + 8 &&
          b.y + b.height + this.player.vel.y * dt >= p.y &&
          b.x + b.width > p.x &&
          b.x < p.x + p.width
        ) {
          this.player.pos.y = p.y - b.height;
          this.player.vel.y = 0;
          this.player.isGrounded = true;
          this.win = true;
        }
        // Score = max height climbed
        this.score = Math.floor(this.maxHeight / 10);
        // Powerup spawn (spawn within visible range if camera hasn't moved much)
        this.powerupTimer += dt;
        if (this.powerupTimer > 5 + Math.random() * 5) {
          const type = Math.random() < 0.5 ? 'blaster' : 'platform';
          const x = 40 + Math.random() * (this.game.canvas.width - 80);
          let y;
          if (this.cameraY < 10) {
            // If camera hasn't moved, spawn powerup within visible area
            y = this.game.canvas.height - 200 - Math.random() * 100;
          } else {
            y = this.cameraY - 100 - Math.random() * 200;
          }
          this.powerups.push(new Powerup(x, y, type));
          this.powerupTimer = 0;
        }
        // Camera only scrolls up if player passes 200px from the top, and never past the top
        const revealThreshold = this.cameraY + 200;
        if (this.player.pos.y < revealThreshold) {
          this.cameraY = Math.max(0, this.player.pos.y - 200);
          // Don't scroll past the top of the world
          this.cameraY = Math.min(this.cameraY, this.worldHeight - this.game.canvas.height);
        }
        this.maxHeight = Math.max(this.maxHeight, this.worldHeight - this.player.pos.y);
      }

      render(ctx) {
        ctx.clearRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        // Background
        const gradient = ctx.createLinearGradient(0, 0, 0, this.game.canvas.height);
        gradient.addColorStop(0, '#87CEEB');
        gradient.addColorStop(1, '#98FB98');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        // Ground (only if visible)
        const groundScreenY = this.worldHeight - 20 - this.cameraY;
        if (groundScreenY < this.game.canvas.height) {
          ctx.fillStyle = '#8B4513';
          ctx.fillRect(0, groundScreenY, this.game.canvas.width, 20);
        }
        // Render platforms
        this.platforms.forEach(platform => {
          ctx.save();
          ctx.translate(0, -this.cameraY);
          platform.render(ctx);
          ctx.restore();
        });
        // Render powerups
        this.powerups.forEach(powerup => {
          ctx.save();
          ctx.translate(0, -this.cameraY);
          powerup.render(ctx);
          ctx.restore();
        });
        // Render player
        ctx.save();
        ctx.translate(0, -this.cameraY);
        this.player.render(ctx);
        ctx.restore();
        // Render bullets
        this.bullets.forEach(bullet => {
          ctx.save();
          ctx.translate(0, -this.cameraY);
          bullet.render(ctx);
          ctx.restore();
        });
        // Render enemies
        this.enemies.forEach(e => {
          ctx.save();
          ctx.translate(0, -this.cameraY);
          ctx.fillStyle = '#ff4d4d';
          ctx.fillRect(e.x, e.y, e.size, e.size);
          // Enemy face
          ctx.fillStyle = 'black';
          ctx.fillRect(e.x + 5, e.y + 5, 4, 4);
          ctx.fillRect(e.x + e.size - 9, e.y + 5, 4, 4);
          ctx.fillRect(e.x + 8, e.y + e.size - 8, e.size - 16, 3);
          ctx.restore();
        });
        // Render finish flag
        ctx.save();
        ctx.translate(0, -this.cameraY);
        // Draw flag platform
        ctx.fillStyle = '#fff';
        ctx.fillRect(this.finishFlag.x, this.finishFlag.y, this.finishFlag.width, this.finishFlag.height);
        // Draw flag pole
        ctx.fillStyle = '#888';
        ctx.fillRect(this.finishFlag.x + this.finishFlag.width - 8, this.finishFlag.y - 32, 6, 32);
        // Draw flag
        ctx.fillStyle = '#f00';
        ctx.beginPath();
        ctx.moveTo(this.finishFlag.x + this.finishFlag.width - 5, this.finishFlag.y - 32);
        ctx.lineTo(this.finishFlag.x + this.finishFlag.width + 25, this.finishFlag.y - 24);
        ctx.lineTo(this.finishFlag.x + this.finishFlag.width - 5, this.finishFlag.y - 16);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        // Draw mines
        this.player.mines.forEach(mine => {
          if (!mine.active) return;
          ctx.save();
          ctx.translate(0, -this.cameraY);
          ctx.beginPath();
          ctx.arc(mine.x, mine.y, mine.radius, 0, Math.PI * 2);
          ctx.fillStyle = '#f80';
          ctx.globalAlpha = 0.85;
          ctx.fill();
          ctx.globalAlpha = 1;
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 3;
          ctx.stroke();
          // Draw a mine symbol
          ctx.beginPath();
          ctx.moveTo(mine.x - 8, mine.y);
          ctx.lineTo(mine.x + 8, mine.y);
          ctx.moveTo(mine.x, mine.y - 8);
          ctx.lineTo(mine.x, mine.y + 8);
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();
        });
        // HUD
        ctx.fillStyle = 'white';
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(`Score: ${this.score}`, 20, 30);
        ctx.fillText(`Enemies: ${this.enemies.length}`, 20, 55);
        ctx.fillText(`Z: Shoot`, 20, 80);
        ctx.fillText(`Shift: Super Mode`, 20, 105);
        ctx.fillText(`Blaster Level: ${this.player.blasterLevel}`, 20, 130);
        ctx.fillText(`Blaster Packs: ` + this.player.blasterPacks.map((v,i)=>v?i+1:'').filter(Boolean).join(', '), 20, 130);
        ctx.fillText(`Active Blaster: ${this.player.blasterLevel}`, 20, 155);
        if (this.player.platformPower > 1) ctx.fillText('Big Platforms!', 20, 155);
        if (this.player.blasterLevel === 4) ctx.fillText(`Mines: ${this.player.mineCount}`, 20, 180);
        if (this.win) {
          ctx.save();
          ctx.globalAlpha = 0.9;
          ctx.fillStyle = '#222';
          ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);
          ctx.globalAlpha = 1;
          ctx.fillStyle = '#fff';
          ctx.font = '48px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('You Win!', this.game.canvas.width / 2, this.game.canvas.height / 2 - 40);
          ctx.font = '24px sans-serif';
          ctx.fillText(`Score: ${this.score}`, this.game.canvas.width / 2, this.game.canvas.height / 2 + 10);
          ctx.fillText('Press R to Restart', this.game.canvas.width / 2, this.game.canvas.height / 2 + 60);
          ctx.restore();
        }
      }

      spawnEnemy() {
        const size = 30;
        const x = Math.random() * (this.game.canvas.width - size);
        this.enemies.push({
          x,
          y: this.cameraY - 60,
          size,
          speed: 100 + Math.random() * 100
        });
      }

      activateBlasterPack(level) {
        this.player.blasterLevel = level;
        this.player.blasterTimer = 5;
        this.player.blasterPacks[level - 1] = false;
        if (level === 4) {
          this.player.mineCount = 3;
          this.player.mines = [];
        }
      }
    }

    // State Manager
    class StateManager {
      constructor(game) {
        this.game = game;
        this.states = {
          menu: new Menu(game),
          classic: new ModeClassic(game),
        };
        this.currentState = null;
      }

      changeState(stateName) {
        if (this.currentState && this.currentState.exit) {
          this.currentState.exit();
        }
        
        if (this.states[stateName]) {
          this.currentState = this.states[stateName];
          this.currentState.enter?.();
        }
      }

      update(dt) {
        this.currentState?.update(dt);
      }

      render(ctx) {
        this.currentState?.render(ctx);
      }
    }

    // Main Game Class
    class Game {
      constructor() {
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        document.getElementById('game-container').appendChild(this.canvas);
        this.resize();

        this.lastTime = 0;
        this.fps = 60;
        this.config = {
          difficulty: 'normal',
          soundEnabled: true,
          particles: true,
        };

        this.stateManager = new StateManager(this);
        this.input = new Input(this.canvas);
        this.audio = new AudioManager();
        this.particles = new ParticleSystem(); // Initialize particles
        this.selectedPlayerType = 0;
      }

      init() {
        this.stateManager.changeState('menu');
        requestAnimationFrame(this.gameLoop.bind(this));
      }

      gameLoop(timestamp) {
        const deltaTime = Math.min((timestamp - this.lastTime) / 1000, 0.016);
        this.lastTime = timestamp;

        this.stateManager.update(deltaTime);
        this.particles.update(deltaTime); // Update particles
        this.stateManager.render(this.ctx);
        this.particles.render(this.ctx); // Render particles

        requestAnimationFrame(this.gameLoop.bind(this));
      }

      resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
      }
    }

    // Initialize the game
    const game = new Game();
    game.init();
  </script>
</body>
</html>